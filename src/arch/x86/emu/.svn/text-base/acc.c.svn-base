/*
 *  Multi2Sim
 *  Copyright (C) 2012  Rafael Ubal (ubal@ece.neu.edu)
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */


/*********************  I n c l u d e s  ****************************/
#include <stdlib.h>

#include <x86-emu.h>
#include <mem-system.h>
#include <x86-timing.h>


/************************  M a c r o s  ****************************/
#define DIMENSION   3				// Gesture (stick to 3 accels)
#define ConfigCycle 9999
#define ReqTime     5

//Number of 'SLICE' in Virtex 6 fp 4 is the most limited resource.
//Area of each benchmarks consumes is modeled with SLICE percentage.
#define AreaTotal    100
#define Area3DES     5.6
#define AreaJacobi   11.3
#define AreaIDSI     5.5
#define AreaSeg      32.8
#define AreaSW       16.0
#define AreaSLAMJ    18.5
#define AreaSLAMC    29.9
#define AreaSURF     31.4

#define Max3DES      17
#define MaxJacobi    8
#define MaxIDSI      18
#define MaxSeg       3
#define MaxSW        6
#define MaxSLAMJ     5
#define MaxSLAMC     3
#define MaxSURF      3

#define MaxAcc       18


/************************ G l o b a l s ****************************/
//Acc delay can begin flag
//Flags are defined in "stg-dispatch.c".
//When this flag is set, dispatch stage will get stuck for several cycles.
extern int DESAccFlag;
extern int JacobiAccFlag;
extern int IDSIAccFlag;
extern int SegAccFlag;
extern int SLAMCAccFlag;
extern int SLAMJAccFlag;
extern int SURFAccFlag;
extern int SWAccFlag;


/*********************  V a r i a b l e s  ****************************/
extern struct x86_cpu_t *x86_cpu;

unsigned long areaLeft = 100;     //Initial value is 100

unsigned long reqCounter = 0;     //obselete
unsigned long preparedCounter = 0;//obselete
unsigned long Cycle_Init =0;      //obselete



static char *err_x86_acc_code =
	"\tAn invalid function code was generated by your application in a ACC system\n"
	"\tcall. Probably, this means that your application is using an incompatible\n"
	"\tversion of the Multi2Sim ACC runtime library ('libm2s-acc'). Please\n"
	"\trecompile your application and try again.\n";

/* Debug */
//int x86_acc_debug_category;


/* List of ACC runtime calls */
enum x86_acc_call_t
{
	x86_acc_call_invalid = 0,
#define X86_ACC_DEFINE_CALL(name, code) x86_acc_call_##name = code,
#include "acc.dat"
#undef X86_ACC_DEFINE_CALL
	x86_acc_call_count
};


/* List of ACC runtime call names */
char *x86_acc_call_name[x86_acc_call_count + 1] =
{
	NULL,
#define X86_ACC_DEFINE_CALL(name, code) #name,
#include "acc.dat"
#undef X86_ACC_DEFINE_CALL
	NULL
};


/* Forward declarations of ACC runtime functions */
#define X86_ACC_DEFINE_CALL(name, code) \
	static int x86_acc_func_##name(struct x86_ctx_t *ctx);
#include "acc.dat"
#undef X86_ACC_DEFINE_CALL


/* List of ACC runtime functions */
typedef int (*x86_acc_func_t)(struct x86_ctx_t *ctx);
static x86_acc_func_t x86_acc_func_table[x86_acc_call_count + 1] =
{
	NULL,
#define X86_ACC_DEFINE_CALL(name, code) x86_acc_func_##name,
#include "acc.dat"
#undef X86_ACC_DEFINE_CALL
	NULL
};

typedef struct arglist
{
	int** sample1;
	int length1;
	int** sample2;
	int length2;
	int i;
	int j;
	int* table;
} arglist;


/*************** F u n c t i o n   D e f i n i t i o n s ***************/

int x86_acc_call(struct x86_ctx_t *ctx)
{
	struct x86_regs_t *regs = ctx->regs;

	/* Variables */
	int code;
	int ret;

	/* Function code */
	code = regs->ebx;
	//printf ("x86_acc_call_count = %d\n",x86_acc_call_count);
	if (code <= x86_acc_call_invalid || code >= x86_acc_call_count)
		fatal("%s: invalid ACC function (code %d).\n%s",
			__FUNCTION__, code, err_x86_acc_code);

	/* Debug */
	//x86_acc_debug("ACC runtime call '%s' (code %d)\n",
	//	x86_acc_call_name[code], code);

	/* Call ACC function */
	assert(x86_acc_func_table[code]);
	ret = x86_acc_func_table[code](ctx);

	/* Return value */
	return ret;
}

//DTW algorithm, return distance
int DTWdistance(int** sample1, int length1, int** sample2, int length2, int i, int j, int* table) 
{
	if( i < 0 || j < 0)
		return 100000000;
	int tableWidth = length2;
	int localDistance = 0;
	int k;
	for (i=0;i<3;i++)
	printf("sample1[0][%d]=%d\n",i,sample1[0][i]);
	for( k = 0; k < DIMENSION; k++)
		localDistance += ((sample1[i][k]-sample2[j][k])*(sample1[i][k]-sample2[j][k]));
		//localDistance += (*(*(sample1+k)+i) - *(*(sample2+k)+j))*(*(*(sample1+k)+i) - *(*(sample2+k)+j));		
		
	int sdistance, s1, s2, s3;
	
	if( i == 0 && j == 0) 
	{
		if( table[i*tableWidth+j] < 0)
			table[i*tableWidth+j] = localDistance;
		return localDistance;
	} 
	else if( i==0) 
	{
		if( table[i*tableWidth+(j-1)] < 0)
			sdistance = DTWdistance(sample1, length1, sample2, length2, i, j-1, table);
		else
			sdistance = table[i*tableWidth+j-1];
	} 
	else if( j==0) 
	{
		if( table[(i-1)*tableWidth+ j] < 0)
			sdistance = DTWdistance(sample1, length1, sample2, length2, i-1, j, table);
		else
			sdistance = table[(i-1)*tableWidth+j];  
	} 
	else 
	{
		if( table[i*tableWidth+(j-1)] < 0)
			s1 = DTWdistance(sample1, length1, sample2, length2, i, j-1, table);
		else
			s1 = table[i*tableWidth+(j-1)];
		if( table[(i-1)*tableWidth+ j] < 0)
			s2 = DTWdistance(sample1, length1, sample2, length2, i-1, j, table);
		else
			s2 = table[(i-1)*tableWidth+ j];
		if( table[(i-1)*tableWidth+ j-1] < 0)
			s3 = DTWdistance(sample1, length1, sample2, length2, i-1, j-1, table);
		else
			s3 = table[(i-1)*tableWidth+ j-1];
		sdistance = s1 < s2 ? s1:s2;
		sdistance = sdistance < s3 ? sdistance:s3;
	}
	table[i*tableWidth+j] = localDistance + sdistance;
	return table[i*tableWidth+j];
}


/*
 * ACC call #1 - accDTW
 *
 * accDTW - DTW algorithm, return distance
 *
 * @return
 *	The function always returns DTW distance
 */

static int x86_acc_func_accDTW (struct x86_ctx_t *ctx)
{
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;
	int core; 
	int thread;
	
	unsigned int args_ptr;
	//int x;
	struct arglist func_args;
	/* Read arguments */
	args_ptr = regs->ecx;


	/* Get function info */
	mem_read(mem, args_ptr, sizeof(arglist), &func_args);
	printf("\t\t**sample1 = %p (%p)\n", func_args.sample1, &(func_args.sample1[0][0]));
	printf("\t\tlength1      = %u (%p)\n", func_args.length1, &func_args.length1);
	printf("\t\t**sample2 = %p (%p)\n", func_args.sample2, &(func_args.sample2[0][0]));
	printf("\t\tlength2      = %u (%p)\n", func_args.length2, &func_args.length2);
	printf("\t\ti               = %u (%p)\n", func_args.i, &func_args.i);
	printf("\t\tj               = %u (%p)\n", func_args.j, &func_args.j);
	printf("\t\t*table       = %p (%p)\n", func_args.table, &(func_args.table[0]));

	/***********************************************/

#define L2ONLY
#define WITHACC


#ifdef L2ONLY
	printf ("Cache Behavior Simulation\n");
	char * mod_name = "mod-l2-0";
	X86_THREAD.data_mod = mem_system_get_mod (mod_name);
#endif

#ifdef WITHACC
	struct linked_list_t *sq = X86_THREAD.sq;
	struct linked_list_t *lq = X86_THREAD.lq;
	struct x86_uop_t *store;
	struct x86_uop_t *load;
	int quant = x86_cpu_issue_width;
	unsigned int count1, count2;

	for (count1 = 0; count1 < 124; count1 ++)
	{
		for(count2 = 0; count2 < 124; count2++)
		{
			linked_list_head(sq);
			while (!linked_list_is_end(sq)&& quant )
			{
				store = linked_list_get(sq);
				printf("\n\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n\n");
				printf("physical addr @ store: %d\n",store->phy_addr);
				assert(store->uinst->opcode == x86_uinst_store);
				if (!store->ready && !x86_reg_file_ready(store))
				{
					linked_list_next(sq);
					continue;
				}


				store->ready = 1;
				printf ("data module kind: %d\n",X86_THREAD.data_mod->kind);
				printf ("data module level: %d\n",X86_THREAD.data_mod->level);
				printf ("data module name: %s\n",X86_THREAD.data_mod->name);
				printf ("data module cache name: %s\n",X86_THREAD.data_mod->cache->name);
				if (!mod_can_access(X86_THREAD.data_mod, store->phy_addr))
				{
					linked_list_next(sq);
					continue;
				}
		
				int i = 3;
				while (i--)
				{
					printf("Store Debug Point 6\n");
					mod_access(X86_THREAD.data_mod, mod_access_store,
						store->phy_addr, NULL, X86_CORE.event_queue, store);
				}
				quant--;
		
				// MMU statistics
				if (*mmu_report_file_name)
					mmu_access_page(store->phy_addr, mmu_access_write);

			}

			quant = x86_cpu_issue_width;

			//printf("Load Simulation ... \n");	
			linked_list_head(lq);
			while (!linked_list_is_end(lq)&& quant )
			{
				load = linked_list_get(lq);
				printf ("physical add @ load: %d\n",load->phy_addr);
				assert(store->uinst->opcode == x86_uinst_store);
				load->ready = 1;
				if (!load->ready && !x86_reg_file_ready(load))
				{
					printf("load debug point 1\n");
					linked_list_next(sq);
					continue;
				}


				load->ready = 1;
				//printf ("physical add: %d\n",load->phy_addr);
				if (!mod_can_access(X86_THREAD.data_mod, store->phy_addr))
				{
					printf("load debug point 2\n");
					linked_list_next(lq);
					continue;
				}
		
				int j = 1;
				while (j--)
				{
					printf("load debug point 3\n");
					mod_access(X86_THREAD.data_mod, mod_access_load,
						load->phy_addr, NULL, X86_CORE.event_queue, load);
				}
				quant--;

				//printf("load debug point 4: quant = %d\n", quant);

				// MMU statistics
				if (*mmu_report_file_name)
					mmu_access_page(load->phy_addr, mmu_access_read);

				// Trace
				x86_trace("x86.inst id=%lld core=%d stg=\"i\"\n",
					load->id_in_core, load->core);
			}
		}
	}
#endif

#ifdef L2ONLY
	mod_name = "mod-dl1-0";
	X86_THREAD.data_mod = mem_system_get_mod (mod_name);
#endif

	/***********************************************/
	int ret = DTWdistance(func_args.sample1, func_args.length1, func_args.sample2, 
		func_args.length2, func_args.i, func_args.j, func_args.table);
	return ret;

}



/*
 * ACC call #2 - accArith
 *
 * accArith - Arithmatic calculation for Whetstone Benchmark
 *
 * @return
 *	The function always returns 0 if running properly;
 *	ruturns -1 if illegal input value is detected
 */
static int x86_acc_func_accArith (struct x86_ctx_t *ctx)
{
	int core = 0; 
	int thread = 0;

	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;


	unsigned int args_ptr;
	double func_args[4];
	/* Read arguments */
	args_ptr = regs->ecx;
	printf ("args_ptr = %u(0x%x)\n\n",args_ptr,args_ptr);
	func_args[0] = 1.0;
	func_args[1] = -1.0;
	func_args[2] = -1.0;
	func_args[3] = -1.0;

	/* Get function info */
	//mem_read(mem, args_ptr, sizeof(double), func_args);

/*
	mem_read(mem, args_ptr+4, 8, func_args[1] );
	mem_read(mem, args_ptr+8, 8, func_args[2] );
	mem_read(mem, args_ptr+12, 8, func_args[3] );
	mem_read(mem, args_ptr+16, 8, func_args[4] );
*/
	//func_args[0] = &args_ptr;
	//func_args[1] = &args_ptr+8;
	//func_args[2] = &args_ptr+16;
	//func_args[3] = &args_ptr+24;
	//func_args[4] = &args_ptr+60;
	printf("*******************************\n");
	printf("In Emulation\n");
	//printf("\t\tfunc_args = %u (0x%x)\n", func_args, func_args);
	printf ("Cycle when getting into this call is %lld\n\n", x86_cpu->cycle); 

	/***********************************************/


	struct linked_list_t *sq = X86_THREAD.sq;
	struct linked_list_t *lq = X86_THREAD.lq;
	struct x86_uop_t *store;
	struct x86_uop_t *load;
	int quant = x86_cpu_issue_width;
	

	linked_list_head(sq);
	while (!linked_list_is_end(sq)&& quant )
	{
		store = linked_list_get(sq);
		printf ("physical addr @ store: %d\n",store->phy_addr);
		//assert(store->uinst->opcode == x86_uinst_store);
		if (!store->ready && !x86_reg_file_ready(store))
		{
			linked_list_next(sq);
			continue;
		}


		store->ready = 1;
		//printf ("physical add: %d\n",load->phy_addr);
		if (!mod_can_access(X86_THREAD.data_mod, store->phy_addr))
		{
			//printf("Debug Point 5\n");
			linked_list_next(sq);
			continue;
		}
		
		int i = 9000;
		while (i--)
		{
			//printf("Debug Point 6\n");
			mod_access(X86_THREAD.data_mod, mod_access_store,
				store->phy_addr, NULL, X86_CORE.event_queue, store);
		}
		quant--;
		
		// MMU statistics
		if (*mmu_report_file_name)
			mmu_access_page(store->phy_addr, mmu_access_write);

	}

	quant = x86_cpu_issue_width;
	
	linked_list_head(lq);
	while (!linked_list_is_end(lq)&& quant )
	{
		load = linked_list_get(lq);
		printf ("physical add @ load: %d\n",load->phy_addr);
		//assert(store->uinst->opcode == x86_uinst_store);
		load->ready = 1;
		if (!load->ready && !x86_reg_file_ready(load))
		{
			printf("load debug point 1\n");
			linked_list_next(sq);
			continue;
		}


		load->ready = 1;
		//printf ("physical add: %d\n",load->phy_addr);
		if (!mod_can_access(X86_THREAD.data_mod, store->phy_addr))
		{
			printf("load debug point 2\n");
			linked_list_next(lq);
			continue;
		}
		
		int j = 9000;
		while (j--)
		{
			//printf("load debug point 3\n");
			mod_access(X86_THREAD.data_mod, mod_access_load,
				load->phy_addr, NULL, X86_CORE.event_queue, load);
		}
		quant--;

		//printf("load debug point 4: quant = %d\n", quant);

		// MMU statistics
		if (*mmu_report_file_name)
			mmu_access_page(load->phy_addr, mmu_access_read);

		// Trace
		x86_trace("x86.inst id=%lld core=%d stg=\"i\"\n",
			load->id_in_core, load->core);
	}



	/***********************************************/
	
/*
	printf("\t\tfunc_args[0] = %u (0x%x)\n", func_args[0], func_args[0]);
	printf("\t\tfunc_args[1] = %u (0x%x)\n", func_args[1], func_args[1]);
	printf("\t\tfunc_args[2] = %u (0x%x)\n", func_args[2], func_args[2]);
	printf("\t\tfunc_args[3] = %u (0x%x)\n", func_args[3], func_args[3]);
	printf("\t\tfunc_args[4] = %u (0x%x)\n", func_args[4], func_args[4]);

	printf("get here 1\n");
*/
/*
	printf("Value:\n\t\tfunc_args[0] = %f (0x%x)\n", *func_args[0], *func_args[0]);
	printf("\t\tfunc_args[1] = %f (0x%x)\n", *func_args[1], *func_args[1]);
	printf("\t\tfunc_args[2] = %f (0x%x)\n", *func_args[2], *func_args[2]);
	printf("\t\tfunc_args[3] = %f (0x%x)\n", *func_args[3], *func_args[3]);
	printf("\t\tfunc_args[4] = %f (0x%x)\n", *func_args[4], *func_args[4]);
*/
/*
	double *A0 = func_args[0];
	double *A1 = func_args[1];
	double *A2 = func_args[2];
	double *A3 = func_args[3];
	double *A4 = func_args[4];
*/
	//double N = *A0;

	//printf("get here\n");
/*
	printf("\t\tN  = %f (0x%x)\n", *A0,*A0);
	printf("\t\tA1 = %f (0x%x)\n", *A1,*A1);
	printf("\t\tA2 = %f (0x%x)\n", *A2,*A2);
	printf("\t\tA3 = %f (0x%x)\n", *A3,*A3);
	printf("\t\tA4 = %f (0x%x)\n", *A4,*A4);
*/

	double T = 0.499975;

	printf ("func_args1 = %f, func_args2 = %f, func_args3 = %f, func_args4 = %f\n",func_args[0],func_args[1],func_args[2],func_args[3]);

/*
	func_args[0] = (func_args[0] + func_args[1] + func_args[2] - func_args[3])*T;
	func_args[1] = (func_args[0] + func_args[1] - func_args[2] + func_args[3])*T;
	func_args[2] = (func_args[0] - func_args[1] + func_args[2] - func_args[3])*T;
	func_args[3] = (-func_args[0] + func_args[1] + func_args[2] + func_args[3])*T;
*/
	return 0;
}




//************************************************************
//************************************************************
//
//  ACC call #3 - accPrintCycle
//
//  accPrintCycle - Print out the current cycle when calling this function
//
//  @return - None
//
//************************************************************
//************************************************************
static int x86_acc_func_accPrintCycle (struct x86_ctx_t *ctx)
{
	int  core;
	int thread;
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	printf("\n***********************************\n");
	printf("* Current CPU cycle is: %llu *", x86_cpu->cycle);
	printf("\n***********************************\n");

	return 0;
}


//************************************************************
//************************************************************
//
//  ACC call #4 - accConfigReq
//
//  accConfigReq - Before calling a certain kind of system call, first try to 
//				request an ACC configuration. Request is only admitted
//				when counter is counted to N.
//
//  @return - Admitted: 1; Denied: 0 (Number of requests are not enough)
//
//************************************************************
//************************************************************
static int x86_acc_func_accConfigReq (struct x86_ctx_t *ctx)
{
	int core;
	int thread;
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	if (reqCounter++ < ReqTime)
		return 0;
	printf ("ACC Configuration Request Accepted!\n");
	reqCounter = 0;
	return 1;
}

//************************************************************
//************************************************************
//
//  ACC call #5 - accConfigPrepared
//
//  accConfigPrepared - After request is admitted, 'CofigCycle' number of 
//				cycles have to be passed until ACC configuration is 
//				ready.
//
//  @return - Preprared: 1; Not Prepared Yet: 0
//
//************************************************************
//************************************************************
static int x86_acc_func_accConfigPrepared (struct x86_ctx_t *ctx)
{
	int core;
	int thread;
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;
	if ( !(preparedCounter ++))
		Cycle_Init = x86_cpu->cycle;
	else if ((x86_cpu->cycle - Cycle_Init) < ConfigCycle)
		return 0;
	preparedCounter = 0;
	printf("ACC Configured!\n");
	return 1;
}

//************************************************************
//************************************************************
//
//  ACC call #6 - acc3DESConfigReq
//
//  accConfigReq - 3DES ACC request
//  return - Admitted: 1; Denied: 0 (Number of requests are not enough)
//
//************************************************************
//************************************************************
static int x86_acc_func_acc3DESConfigReq (struct x86_ctx_t *ctx)
{
	int core;
	int thread;
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;
	if (ctx->accStatus.withAcc && !ctx->accStatus.prepareTime)
		return 0;
	else if (ctx->accStatus.type != DES)
	{
		ctx->accStatus.withAcc	   = 0;
		ctx->accStatus.type 	   = DES;
		ctx->accStatus.requestsNum = 0;
		ctx->accStatus.prepareTime = 0;
		ctx->accStatus.initCycle   = 0;
		return 0;
	}
	else if (ctx->accStatus.requestsNum < ReqTime
		 && !ctx->accStatus.prepareTime)
	{
		ctx->accStatus.requestsNum ++;
		return 0;
	}
	else
	{
		//printf ("3DES ACC Configuration Request Accepted!\n");
		ctx->accStatus.withAcc = 1;
		return 1;
	}
}




//************************************************************
//************************************************************
//
//  ACC call #7 - accJacobiConfigReq
//
//  accConfigReq - Jacobian ACC request
//  return - Admitted: 1; Denied: 0 (Number of requests are not enough)
//
//************************************************************
//************************************************************
static int x86_acc_func_accJacobiConfigReq (struct x86_ctx_t *ctx)
{
	int core;
	int thread;
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;
	if (ctx->accStatus.withAcc && !ctx->accStatus.prepareTime)
		return 0;
	else if (ctx->accStatus.type != Jacobi)
	{
		ctx->accStatus.withAcc	   = 0;
		ctx->accStatus.type 	   = Jacobi;
		ctx->accStatus.requestsNum = 0;
		ctx->accStatus.prepareTime = 0;
		ctx->accStatus.initCycle   = 0;
		return 0;
	}
	else if (ctx->accStatus.requestsNum < ReqTime
		 && !ctx->accStatus.prepareTime)
	{
		ctx->accStatus.requestsNum ++;
		return 0;
	}
	else
	{
		//printf ("Jacobi ACC Configuration Request Accepted!\n");
		ctx->accStatus.withAcc = 1;
		return 1;
	}
}


//************************************************************
//************************************************************
//
//  ACC call #8 - accIDSIConfigReq
//
//  accConfigReq - IDSI ACC request
//  return - Admitted: 1; Denied: 0 (Number of requests are not enough)
//
//************************************************************
//************************************************************
static int x86_acc_func_accIDSIConfigReq (struct x86_ctx_t *ctx)
{
	int core;
	int thread;
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;
	if (ctx->accStatus.withAcc && !ctx->accStatus.prepareTime)
		return 0;
	else if (ctx->accStatus.type != IDSI)
	{
		ctx->accStatus.withAcc	   = 0;
		ctx->accStatus.type 	   = IDSI;
		ctx->accStatus.requestsNum = 0;
		ctx->accStatus.prepareTime = 0;
		ctx->accStatus.initCycle   = 0;
		return 0;
	}
	else if (ctx->accStatus.requestsNum < ReqTime
		 && !ctx->accStatus.prepareTime)
	{
		ctx->accStatus.requestsNum ++;
		return 0;
	}
	else
	{
		//printf ("IDSI ACC Configuration Request Accepted!\n");
		ctx->accStatus.withAcc = 1;
		return 1;
	}
}



//************************************************************
//************************************************************
//
//  ACC call #9 - accSegConfigReq
//
//  accConfigReq - Segmentation ACC request
//  return - Admitted: 1; Denied: 0 (Number of requests are not enough)
//
//************************************************************
//************************************************************
static int x86_acc_func_accSegConfigReq (struct x86_ctx_t *ctx)
{
	int core;
	int thread;
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;
	if (ctx->accStatus.withAcc && !ctx->accStatus.prepareTime)
		return 0;
	else if (ctx->accStatus.type != Seg)
	{
		ctx->accStatus.withAcc	   = 0;
		ctx->accStatus.type 	   = Seg;
		ctx->accStatus.requestsNum = 0;
		ctx->accStatus.prepareTime = 0;
		ctx->accStatus.initCycle   = 0;
		return 0;
	}
	else if (ctx->accStatus.requestsNum < ReqTime
		 && !ctx->accStatus.prepareTime)
	{
		ctx->accStatus.requestsNum ++;
		return 0;
	}
	else
	{
		//printf ("Seg ACC Configuration Request Accepted!\n");
		ctx->accStatus.withAcc = 1;
		return 1;
	}
}


//************************************************************
//************************************************************
//
//  ACC call #10 - accSWConfigReq
//
//  accConfigReq - Smith-waterman ACC request
//  return - Admitted: 1; Denied: 0 (Number of requests are not enough)
//
//************************************************************
//************************************************************
static int x86_acc_func_accSWConfigReq (struct x86_ctx_t *ctx)
{
	int core;
	int thread;
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;
	if (ctx->accStatus.withAcc && !ctx->accStatus.prepareTime)
		return 0;
	else if (ctx->accStatus.type != SW)
	{
		ctx->accStatus.withAcc	   = 0;
		ctx->accStatus.type 	   = SW;
		ctx->accStatus.requestsNum = 0;
		ctx->accStatus.prepareTime = 0;
		ctx->accStatus.initCycle   = 0;
		return 0;
	}
	else if (ctx->accStatus.requestsNum < ReqTime
		 && !ctx->accStatus.prepareTime)
	{
		ctx->accStatus.requestsNum ++;
		return 0;
	}
	else
	{
		//printf ("SW ACC Configuration Request Accepted!\n");
		ctx->accStatus.withAcc = 1;
		return 1;
	}
}



//************************************************************
//************************************************************
//
//  ACC call #11 - accSLAMCConfigReq
//
//  accConfigReq - SLAM-Coordinate ACC request
//  return - Admitted: 1; Denied: 0 (Number of requests are not enough)
//
//************************************************************
//************************************************************
static int x86_acc_func_accSLAMCConfigReq (struct x86_ctx_t *ctx)
{
	int core;
	int thread;
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;
	if (ctx->accStatus.withAcc && !ctx->accStatus.prepareTime)
		return 0;
	else if (ctx->accStatus.type != SLAMC)
	{
		ctx->accStatus.withAcc     = 0;
		ctx->accStatus.type        = SLAMC;
		ctx->accStatus.requestsNum = 0;
		ctx->accStatus.prepareTime = 0;
		ctx->accStatus.initCycle   = 0;
		return 0;
	}
	else if (ctx->accStatus.requestsNum < ReqTime
		 && !ctx->accStatus.prepareTime)
	{
		ctx->accStatus.requestsNum ++;
		return 0;
	}
	else
	{
		//printf ("SLAMC ACC Configuration Request Accepted!\n");
		ctx->accStatus.withAcc = 1;
		return 1;
	}
}



//************************************************************
//************************************************************
//
//  ACC call #12 - accSLAMJConfigReq
//
//  accConfigReq - SLAM-Jacobian ACC request
//  return - Admitted: 1; Denied: 0 (Number of requests are not enough)
//
//************************************************************
//************************************************************
static int x86_acc_func_accSLAMJConfigReq (struct x86_ctx_t *ctx)
{
	int core;
	int thread;
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;
	if (ctx->accStatus.withAcc && !ctx->accStatus.prepareTime)
		return 0;
	else if (ctx->accStatus.type != SLAMJ)
	{
		ctx->accStatus.withAcc	   = 0;
		ctx->accStatus.type 	   = SLAMJ;
		ctx->accStatus.requestsNum = 0;
		ctx->accStatus.prepareTime = 0;
		ctx->accStatus.initCycle   = 0;
		return 0;
	}
	else if (ctx->accStatus.requestsNum < ReqTime
		 && !ctx->accStatus.prepareTime)
	{
		ctx->accStatus.requestsNum ++;
		return 0;
	}
	else
	{
		//printf ("SLAMJ ACC Configuration Request Accepted!\n");
		ctx->accStatus.withAcc = 1;
		return 1;
	}
}


//************************************************************
//************************************************************
//
//  ACC call #13 - accSURFConfigReq
//
//  accConfigReq - SURF ACC request
//  return - Admitted: 1; Denied: 0 (Number of requests are not enough)
//
//************************************************************
//************************************************************
static int x86_acc_func_accSURFConfigReq (struct x86_ctx_t *ctx)
{
	int core;
	int thread;
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;
	if (ctx->accStatus.withAcc && !ctx->accStatus.prepareTime)
		return 0;
	else if (ctx->accStatus.type != SURF)
	{
		ctx->accStatus.withAcc	   = 0;
		ctx->accStatus.type 	   = SURF;
		ctx->accStatus.requestsNum = 0;
		ctx->accStatus.prepareTime = 0;
		ctx->accStatus.initCycle   = 0;
		return 0;
	}
	else if (ctx->accStatus.requestsNum < ReqTime
		 && !ctx->accStatus.prepareTime)
	{
		ctx->accStatus.requestsNum ++;
		return 0;
	}
	else
	{
		//printf ("SURF ACC Configuration Request Accepted!\n");
		ctx->accStatus.withAcc = 1;
		return 1;
	}
}


//************************************************************
//************************************************************
//
//  ACC call #14 - acc3DESConfigPrepared
//
//  accConfigPrepared - After request is admitted, 'CofigCycle' number of 
//				cycles have to be passed until ACC configuration is 
//				ready.
//
//  @return - Preprared: 1; Not Prepared Yet: 0
//
//************************************************************
//************************************************************
static int x86_acc_func_acc3DESConfigPrepared (struct x86_ctx_t *ctx)
{
	int core;
	int thread;
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	if (ctx->accStatus.withAcc == 0)
		return 0;
	else if (ctx->accStatus.prepareTime == 0)
	{
		ctx->accStatus.initCycle = x86_cpu->cycle;
		ctx->accStatus.prepareTime ++;
		return 0;
	}
	else if ((x86_cpu->cycle - ctx->accStatus.initCycle) < ConfigCycle)
	{
		ctx->accStatus.prepareTime ++;
		return 0;
	}
	else
	{
		//printf ("3DES Acc Configured!\n");
		return 1;
	}
}

//************************************************************
//************************************************************
//
//  ACC call #15 - accJacobiConfigPrepared
//
//  accConfigPrepared - After request is admitted, 'CofigCycle' number of 
//				cycles have to be passed until ACC configuration is 
//				ready.
//
//  @return - Preprared: 1; Not Prepared Yet: 0
//
//************************************************************
//************************************************************
static int x86_acc_func_accJacobiConfigPrepared (struct x86_ctx_t *ctx)
{
	int core;
	int thread;
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	if (ctx->accStatus.withAcc == 0)
		return 0;
	else if (ctx->accStatus.prepareTime == 0)
	{
		ctx->accStatus.initCycle = x86_cpu->cycle;
		ctx->accStatus.prepareTime ++;
		return 0;
	}
	else if ((x86_cpu->cycle - ctx->accStatus.initCycle) < ConfigCycle)
	{
		ctx->accStatus.prepareTime ++;
		return 0;
	}
	else
	{
		//printf ("Jacobi Acc Configured!\n");
		return 1;
	}
}

//************************************************************
//************************************************************
//
//  ACC call #16 - accIDSIConfigPrepared
//
//  accConfigPrepared - After request is admitted, 'CofigCycle' number of 
//				cycles have to be passed until ACC configuration is 
//				ready.
//
//  @return - Preprared: 1; Not Prepared Yet: 0
//
//************************************************************
//************************************************************
static int x86_acc_func_accIDSIConfigPrepared (struct x86_ctx_t *ctx)
{
	int core;
	int thread;
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	if (ctx->accStatus.withAcc == 0)
		return 0;
	else if (ctx->accStatus.prepareTime == 0)
	{
		ctx->accStatus.initCycle = x86_cpu->cycle;
		ctx->accStatus.prepareTime ++;
		return 0;
	}
	else if ((x86_cpu->cycle - ctx->accStatus.initCycle) < ConfigCycle)
	{
		ctx->accStatus.prepareTime ++;
		return 0;
	}
	else
	{
		//printf ("IDSI Acc Configured!\n");
		return 1;
	}
}

//************************************************************
//************************************************************
//
//  ACC call #17 - accJacobiConfigPrepared
//
//  accConfigPrepared - After request is admitted, 'CofigCycle' number of 
//				cycles have to be passed until ACC configuration is 
//				ready.
//
//  @return - Preprared: 1; Not Prepared Yet: 0
//
//************************************************************
//************************************************************
static int x86_acc_func_accSegConfigPrepared (struct x86_ctx_t *ctx)
{
	int core;
	int thread;
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	if (ctx->accStatus.withAcc == 0)
		return 0;
	else if (ctx->accStatus.prepareTime == 0)
	{
		ctx->accStatus.initCycle = x86_cpu->cycle;
		ctx->accStatus.prepareTime ++;
		return 0;
	}
	else if ((x86_cpu->cycle - ctx->accStatus.initCycle) < ConfigCycle)
	{
		ctx->accStatus.prepareTime ++;
		return 0;
	}
	else
	{
		//printf ("Seg Acc Configured!\n");
		return 1;
	}
}


//************************************************************
//************************************************************
//
//  ACC call #18 - accSWConfigPrepared
//
//  accConfigPrepared - After request is admitted, 'CofigCycle' number of 
//				cycles have to be passed until ACC configuration is 
//				ready.
//
//  @return - Preprared: 1; Not Prepared Yet: 0
//
//************************************************************
//************************************************************
static int x86_acc_func_accSWConfigPrepared (struct x86_ctx_t *ctx)
{
	int core;
	int thread;
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	if (ctx->accStatus.withAcc == 0)
		return 0;
	else if (ctx->accStatus.prepareTime == 0)
	{
		ctx->accStatus.initCycle = x86_cpu->cycle;
		ctx->accStatus.prepareTime ++;
		return 0;
	}
	else if ((x86_cpu->cycle - ctx->accStatus.initCycle) < ConfigCycle)
	{
		ctx->accStatus.prepareTime ++;
		return 0;
	}
	else
	{
		//printf ("SW Acc Configured!\n");
		return 1;
	}
}

//************************************************************
//************************************************************
//
//  ACC call #19 - accSLAMCConfigPrepared
//
//  accConfigPrepared - After request is admitted, 'CofigCycle' number of 
//				cycles have to be passed until ACC configuration is 
//				ready.
//
//  @return - Preprared: 1; Not Prepared Yet: 0
//
//************************************************************
//************************************************************
static int x86_acc_func_accSLAMCConfigPrepared (struct x86_ctx_t *ctx)
{
	int core;
	int thread;
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	if (ctx->accStatus.withAcc == 0)
		return 0;
	else if (ctx->accStatus.prepareTime == 0)
	{
		ctx->accStatus.initCycle = x86_cpu->cycle;
		ctx->accStatus.prepareTime ++;
		return 0;
	}
	else if ((x86_cpu->cycle - ctx->accStatus.initCycle) < ConfigCycle)
	{
		return 0;
	}
	else
	{
		//printf ("SLAMC Acc Configured!\n");
		return 1;
	}
}

//************************************************************
//************************************************************
//
//  ACC call #20 - accSLAMJConfigPrepared
//
//  accConfigPrepared - After request is admitted, 'CofigCycle' number of 
//				cycles have to be passed until ACC configuration is 
//				ready.
//
//  @return - Preprared: 1; Not Prepared Yet: 0
//
//************************************************************
//************************************************************
static int x86_acc_func_accSLAMJConfigPrepared (struct x86_ctx_t *ctx)
{
	int core;
	int thread;
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	if (ctx->accStatus.withAcc == 0)
	{
		return 0;
	}
	else if (ctx->accStatus.prepareTime == 0)
	{
		ctx->accStatus.initCycle = x86_cpu->cycle;
		ctx->accStatus.prepareTime ++;
		return 0;
	}
	else if ((x86_cpu->cycle - ctx->accStatus.initCycle) < ConfigCycle)
	{
		return 0;
	}
	else
	{
		//printf ("SLAMJ Acc Configured!\n");
		return 1;
	}
}

//************************************************************
//************************************************************
//
//  ACC call #21 - accJacobiSURFPrepared
//
//  accConfigPrepared - After request is admitted, 'CofigCycle' number of 
//				cycles have to be passed until ACC configuration is 
//				ready.
//
//  @return - Preprared: 1; Not Prepared Yet: 0
//
//************************************************************
//************************************************************
static int x86_acc_func_accSURFConfigPrepared (struct x86_ctx_t *ctx)
{
	int core;
	int thread;
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	if (ctx->accStatus.withAcc == 0)
		return 0;
	else if (ctx->accStatus.prepareTime == 0)
	{
		ctx->accStatus.initCycle = x86_cpu->cycle;
		ctx->accStatus.prepareTime ++;
		return 0;
	}
	else if ((x86_cpu->cycle - ctx->accStatus.initCycle) < ConfigCycle)
	{
		ctx->accStatus.prepareTime ++;
		return 0;
	}
	else
	{
		//printf ("SURF Acc Configured!\n");
		return 1;
	}
}

//************************************************************
//************************************************************
//
//  ACC call #22 - acc3DESRelease
//
//  Clear the "withAcc" status, return acc type to NOACC and clear counters
//
//  @return - 0 -- New Acc type     1 -- Same Acc type
//
//************************************************************
//************************************************************
static int x86_acc_func_acc3DESRelease (struct x86_ctx_t *ctx)
{
	int core;
	int thread;
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	if (ctx->accStatus.type != DES)
	{
		ctx->accStatus.withAcc = 0;
		ctx->accStatus.type    = NOACC;
		ctx->accStatus.requestsNum = 0;
		ctx->accStatus.prepareTime = 0;
		ctx->accStatus.initCycle   = 0;
		return 0;
	}
	else
	{
		ctx->accStatus.withAcc = 1;
		ctx->accStatus.requestsNum = 0;
		ctx->accStatus.prepareTime = 0;
		ctx->accStatus.initCycle   = 0;
		return 1;
	}
}	


//************************************************************
//************************************************************
//
//  ACC call #23 - accJacobiRelease
//
//  Clear the "withAcc" status, return acc type to NOACC and clear counters
//
//  @return - None
//
//************************************************************
//************************************************************
static int x86_acc_func_accJacobiRelease (struct x86_ctx_t *ctx)
{
	int core;
	int thread;
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	if (ctx->accStatus.type != Jacobi)
	{
		ctx->accStatus.withAcc = 0;
		ctx->accStatus.type    = NOACC;
		ctx->accStatus.requestsNum = 0;
		ctx->accStatus.prepareTime = 0;
		ctx->accStatus.initCycle   = 0;
	}
	return 1;
}


//************************************************************
//************************************************************
//
//  ACC call #24 - accIDSIRelease
//
//  Clear the "withAcc" status, return acc type to NOACC and clear counters
//
//  @return - None
//
//************************************************************
//************************************************************
static int x86_acc_func_accIDSIRelease (struct x86_ctx_t *ctx)
{
	int core;
	int thread;
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	if (ctx->accStatus.type != IDSI)
	{
		ctx->accStatus.withAcc = 0;
		ctx->accStatus.type    = NOACC;
		ctx->accStatus.requestsNum = 0;
		ctx->accStatus.prepareTime = 0;
		ctx->accStatus.initCycle   = 0;
	}
	return 1;
}


//************************************************************
//************************************************************
//
//  ACC call #25 - accSegRelease
//
//  Clear the "withAcc" status, return acc type to NOACC and clear counters
//
//  @return - None
//
//************************************************************
//************************************************************
static int x86_acc_func_accSegRelease (struct x86_ctx_t *ctx)
{
	int core;
	int thread;
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	if (ctx->accStatus.type != Seg)
	{
		ctx->accStatus.withAcc = 0;
		ctx->accStatus.type    = NOACC;
		ctx->accStatus.requestsNum = 0;
		ctx->accStatus.prepareTime = 0;
		ctx->accStatus.initCycle   = 0;
	}
	return 1;
}


//************************************************************
//************************************************************
//
//  ACC call #26 - accSWRelease
//
//  Clear the "withAcc" status, return acc type to NOACC and clear counters
//
//  @return - None
//
//************************************************************
//************************************************************
static int x86_acc_func_accSWRelease (struct x86_ctx_t *ctx)
{
	int core;
	int thread;
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	if (ctx->accStatus.type != SW)
	{
		ctx->accStatus.withAcc = 0;
		ctx->accStatus.type    = NOACC;
		ctx->accStatus.requestsNum = 0;
		ctx->accStatus.prepareTime = 0;
		ctx->accStatus.initCycle   = 0;
	}
	return 1;
}


//************************************************************
//************************************************************
//
//  ACC call #27 - accSLAMCRelease
//
//  Clear the "withAcc" status, return acc type to NOACC and clear counters
//
//  @return - None
//
//************************************************************
//************************************************************
static int x86_acc_func_accSLAMCRelease (struct x86_ctx_t *ctx)
{
	int core;
	int thread;
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	if (ctx->accStatus.type != SLAMC)
	{
		ctx->accStatus.withAcc = 0;
		ctx->accStatus.type    = NOACC;
		ctx->accStatus.requestsNum = 0;
		ctx->accStatus.prepareTime = 0;
		ctx->accStatus.initCycle   = 0;
	}
	return 1;
}



//************************************************************
//************************************************************
//
//  ACC call #28 - accSLAMJRelease
//
//  Clear the "withAcc" status, return acc type to NOACC and clear counters
//
//  @return - None
//
//************************************************************
//************************************************************
static int x86_acc_func_accSLAMJRelease (struct x86_ctx_t *ctx)
{
	int core;
	int thread;
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	if (ctx->accStatus.type != SLAMJ)
	{
		ctx->accStatus.withAcc = 0;
		ctx->accStatus.type    = NOACC;
		ctx->accStatus.requestsNum = 0;
		ctx->accStatus.prepareTime = 0;
		ctx->accStatus.initCycle   = 0;
	}
	return 1;
}



//************************************************************
//************************************************************
//
//  ACC call #29 - accSURFRelease
//
//  Clear the "withAcc" status, return acc type to NOACC and clear counters
//
//  @return - None
//
//************************************************************
//************************************************************
static int x86_acc_func_accSURFRelease (struct x86_ctx_t *ctx)
{
	int core;
	int thread;
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	if (ctx->accStatus.type != SURF)
	{
		ctx->accStatus.withAcc = 0;
		ctx->accStatus.type    = NOACC;
		ctx->accStatus.requestsNum = 0;
		ctx->accStatus.prepareTime = 0;
		ctx->accStatus.initCycle   = 0;
	}
	return 1;
}


//************************************************************
//************************************************************
//
//  ACC call #30 - acc3DES
//
//  Set global flag and signal the dispatch stage that Acc could start
//
//  @return - 1 when done
//
//************************************************************
//************************************************************
static int x86_acc_func_acc3DES (struct x86_ctx_t *ctx)
{
	int core;
	int thread;
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	DESAccFlag = 1;

	return 1;
}

//************************************************************
//************************************************************
//
//  ACC call #31 - accJacobi
//
//  Set global flag and signal the dispatch stage that Acc could start
//
//  @return - 1 when done
//
//************************************************************
//************************************************************
static int x86_acc_func_accJacobi (struct x86_ctx_t *ctx)
{
	int core;
	int thread;
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	JacobiAccFlag = 1;

	return 1;
}

//************************************************************
//************************************************************
//
//  ACC call #32 - accIDSI
//
//  Set global flag and signal the dispatch stage that Acc could start
//
//  @return - 1 when done
//
//************************************************************
//************************************************************
static int x86_acc_func_accIDSI (struct x86_ctx_t *ctx)
{
	int core;
	int thread;
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	IDSIAccFlag = 1;

	return 1;
}

//************************************************************
//************************************************************
//
//  ACC call #33 - accSeg
//
//  Set global flag and signal the dispatch stage that Acc could start
//
//  @return - 1 when done
//
//************************************************************
//************************************************************
static int x86_acc_func_accSeg (struct x86_ctx_t *ctx)
{
	int core;
	int thread;
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	SegAccFlag = 1;

	return 1;
}


//************************************************************
//************************************************************
//
//  ACC call #34 - accSW
//
//  Set global flag and signal the dispatch stage that Acc could start
//
//  @return - 1 when done
//
//************************************************************
//************************************************************
static int x86_acc_func_accSW (struct x86_ctx_t *ctx)
{
	int core;
	int thread;
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	SWAccFlag = 1;

	return 1;
}


//************************************************************
//************************************************************
//
//  ACC call #35 - accSLAMC
//
//  Set global flag and signal the dispatch stage that Acc could start
//
//  @return - 1 when done
//
//************************************************************
//************************************************************
static int x86_acc_func_accSLAMC (struct x86_ctx_t *ctx)
{
	int core;
	int thread;
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	SLAMCAccFlag = 1;

	return 1;
}


//************************************************************
//************************************************************
//
//  ACC call #36 - accSLAMJ
//
//  Set global flag and signal the dispatch stage that Acc could start
//
//  @return - 1 when done
//
//************************************************************
//************************************************************
static int x86_acc_func_accSLAMJ (struct x86_ctx_t *ctx)
{
	int core;
	int thread;
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	SLAMJAccFlag = 1;
	return 1;
}


//************************************************************
//************************************************************
//
//  ACC call #37 - accSURF
//
//  Set global flag and signal the dispatch stage that Acc could start
//
//  @return - 1 when done
//
//************************************************************
//************************************************************
static int x86_acc_func_accSURF (struct x86_ctx_t *ctx)
{
	int core;
	int thread;
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	SURFAccFlag = 1;

	return 1;
}

